{"version":3,"file":"ngx-scroll-position-restoration.mjs","sources":["../../../projects/ngx-scroll-position-restoration/src/lib/dom-utils.ts","../../../projects/ngx-scroll-position-restoration/src/lib/ngx-scroll-position-restoration-config-injection-token.ts","../../../projects/ngx-scroll-position-restoration/src/lib/ngx-scroll-position-restoration.service.ts","../../../projects/ngx-scroll-position-restoration/src/lib/custom-router-outlet.directive.ts","../../../projects/ngx-scroll-position-restoration/src/lib/default-ngx-scroll-position-restoration-config.ts","../../../projects/ngx-scroll-position-restoration/src/lib/ngx-scroll-position-restoration.module.ts","../../../projects/ngx-scroll-position-restoration/src/public-api.ts","../../../projects/ngx-scroll-position-restoration/src/ngx-scroll-position-restoration.ts"],"sourcesContent":["\nimport { finder } from '@medv/finder';\n\nexport const WINDOW_SELECTOR = '__window-selector__';\n\nexport type Target = Window | Element;\n\n/**\n * DomUtils\n * \n * I provide a unified interface for dealing with scroll offsets across different types of targets (elements vs. windows).\n */\n\n/**\n * I get the scroll-top of the given target in the active DOM.\n */\nexport function getScrollTop(target: Target): number {\n  if (target instanceof Window) {\n    return window.scrollY;\n  } else {\n    return target.scrollTop;\n  }\n}\n\n/**\n * I return the CSS selector for the given target.\n * ___\n * NOTE: The generated selector is intended to be consumed by this class only - it may not produce a valid CSS selector.\n */\nexport function getSelector(target: Target): string | null {\n\n  // NOTE: I am breaking this apart because TypeScript was having trouble dealing\n  // with type-guard. I believe this is part of this bug:\n  // --\n  // https://github.com/Microsoft/TypeScript/issues/7271#issuecomment-360123191\n  if (target instanceof Window) {\n    return WINDOW_SELECTOR;\n  } else {\n    // If the given element is not part of the active document, there's no way for us\n    // to calculate a selector for it.\n    if (!document.body.contains(target)) {\n      return null;\n    }\n    return finder(target);\n  }\n}\n\n/**\n *  I get the scrollable target for the given 'scroll' event.\n * ___\n * NOTE: If you want to ignore (ie, not reinstate the scroll) of a particular type of DOM element, return NULL from this method.\n */\nexport function getTargetFromScrollEvent(event: Event): Target | null {\n  const node = event.target;\n  if (node instanceof HTMLDocument) {\n    return window;\n  } else if (node instanceof Element) {\n    return node;\n  }\n  return null;\n}\n\n/**\n * I attempt to scroll the given target to the given scrollTop and return the resultant value presented by the target.\n * @param target \n * @param scrollTop \n * @returns resultant scroll top.\n */\nexport function scrollTo(target: Target, scrollTop: number): number | null {\n  if (target instanceof Window) {\n    target.scrollTo(0, scrollTop);\n    return target.scrollY;\n  } else if (target instanceof Element) {\n    target.scrollTop = scrollTop;\n    return target.scrollTop;\n  }\n  return null\n}\n\n/**\n * I return the target accessible at the given CSS selector.\n */\nexport function select(selector: string): Target | null {\n  if (selector === WINDOW_SELECTOR) {\n    return window;\n  } else {\n    return document.querySelector(selector);\n  }\n}\n\n\n/**\n * Source:\n * - https://www.bennadel.com/blog/3534-restoring-and-resetting-the-scroll-position-using-the-navigationstart-event-in-angular-7-0-4.htm\n * - http://bennadel.github.io/JavaScript-Demos/demos/router-retain-scroll-polyfill-angular7/\n * - https://github.com/bennadel/JavaScript-Demos/tree/master/demos/router-retain-scroll-polyfill-angular7\n */","import { InjectionToken } from '@angular/core';\r\nimport { NgxScrollPositionRestorationConfig } from './ngx-scroll-position-restoration-config';\r\n\r\nexport const NGX_SCROLL_POSITION_RESTORATION_CONFIG_INJECTION_TOKEN = new InjectionToken<NgxScrollPositionRestorationConfig>('ngx_scroll_position_restoration_config_injection_token');\r\n","import { isPlatformServer } from '@angular/common';\nimport { Inject, Injectable, NgZone, OnDestroy, PLATFORM_ID } from '@angular/core';\nimport { NavigationStart, Router, Event as RouterNavigationEvent, NavigationEnd } from '@angular/router';\nimport { Subject, takeUntil } from 'rxjs';\nimport * as DomUtils from './dom-utils';\nimport { NgxScrollPositionRestorationConfig } from './ngx-scroll-position-restoration-config';\nimport { NGX_SCROLL_POSITION_RESTORATION_CONFIG_INJECTION_TOKEN } from './ngx-scroll-position-restoration-config-injection-token';\n\n@Injectable()\nexport class NgxScrollPositionRestorationService implements OnDestroy {\n\n  private applyStateToDomTimer: number = 0;\n  private currentPageState: PageState = {};\n  private lastNavigationStartAt: number = 0;\n  private navigationIDs: number[] = [];\n  private pageStates: PageStates = {};\n  private scrolledElements: Set<Target> = new Set();\n\n  // We need to keep track of these values across the Start / End events.\n  private navigationID!: number;\n  private restoredNavigationID!: number | null;\n\n  private maximumNumberOfCachedPageStates: number = 20;\n\n  private serviceDestroyed$ = new Subject<void>();\n\n  constructor(\n    private router: Router,\n    private zone: NgZone,\n    @Inject(PLATFORM_ID) private platformId: string,\n    @Inject(NGX_SCROLL_POSITION_RESTORATION_CONFIG_INJECTION_TOKEN) private config: NgxScrollPositionRestorationConfig\n  ) { }\n\n  /**\n   * Initialize NgxScrollPositionRestorationService.\n   */\n  initialize(): void {\n    if (isPlatformServer(this.platformId)) {\n      return;\n    }\n\n    this.setupScrollBinding();\n\n    // this.setupRouterBinding();\n    // I bind to the router events and perform to primary actions:\n    // --\n    // NAVIGATION START: When the user is about to navigate away from the current view,\n    // I inspect the current DOM state and commit any scrolled-element offsets to the\n    // in-memory cache of the page state (scroll events were recorded during the lifetime\n    // of the current router state).\n    // --\n    // NAVIGATION END: When the user completes a navigation to a new view, I check to see\n    // if the new view is really the restoration of a previously cached page state; and,\n    // if so, I try to reinstate the old scrolled-element offsets in the rendered DOM.\n    this.router.events.pipe(\n      takeUntil(this.serviceDestroyed$)\n    ).subscribe(\n      (event: RouterNavigationEvent) => {\n        // Filter navigation event streams to the appropriate event handlers.\n        if (event instanceof NavigationStart) {\n          this.handleNavigationStart(event);\n        } else if (event instanceof NavigationEnd) {\n          this.handleNavigationEnd();\n        }\n      }\n    );\n\n    // Since we're going to be implementing a custom scroll retention algorithm,\n    // let's disable the one that is provided by the browser. This will keep our\n    // polyfill the source of truth.\n    this.disableBrowserDefaultScrollRestoration();\n  }\n\n  ngOnDestroy(): void {\n    this.serviceDestroyed$.next();\n    this.serviceDestroyed$.complete();\n  }\n\n  clearSavedWindowScrollTopInLastNavigation(): void {\n    const lastNavigationId = this.navigationIDs[this.navigationIDs.length - 1];\n    if (lastNavigationId) {\n      if (this.config.debug && this.pageStates[lastNavigationId][DomUtils.WINDOW_SELECTOR]) {\n        console.log('Navigation in a \"secondary\" router-outlet - Remove window scroll position from recorded scroll positions.');\n      }\n      delete (this.pageStates[lastNavigationId][DomUtils.WINDOW_SELECTOR]);\n    }\n  }\n\n  /**\n   * I attempt to apply the given page-state to the rendered DOM. I will continue to poll the document until all states have been reinstated; or, until the poll duration has been exceeded; or, until a subsequent navigation takes place.\n   */\n  private applyPageStateToDom(pageState: PageState): void {\n    if (this.config.debug) {\n      this.debugPageState(pageState, 'Attempting to reapply scroll positions after a popstate navigation (backward or forward).');\n    }\n\n    if (this.objectIsEmpty(pageState)) {\n      return;\n    }\n\n    // Let's create a copy of the page state so that we can safely delete keys from\n    // it as we successfully apply them to the rendered DOM.\n    const pendingPageState = { ...pageState };\n\n    // Setup the scroll retention timer outside of the Angular Zone so that it\n    // doesn't trigger any additional change-detection digests.\n    this.zone.runOutsideAngular(\n      (): void => {\n        const startedAt = Date.now();\n\n        this.applyStateToDomTimer = setInterval(\n          () => {\n            for (const selector in pendingPageState) {\n              const target = DomUtils.select(selector);\n\n              // If the target element doesn't exist in the DOM yet, it\n              // could be an indication of asynchronous loading and\n              // rendering. Move onto the next selector while we still\n              // have time.\n              if (!target) {\n                continue;\n              }\n\n              // If the element in question has been scrolled (by the user)\n              // while we're attempting to reinstate the previous scroll\n              // offsets, then ignore this state - the user's action should\n              // take precedence.\n              if (this.scrolledElements.has(target)) {\n                delete (pendingPageState[selector]);\n                // Otherwise, let's try to restore the scroll for the target.\n              } else {\n                const scrollTop = pendingPageState[selector];\n                const resultantScrollTop = DomUtils.scrollTo(target, scrollTop);\n\n                // If the attempt to restore the element to its previous\n                // offset resulted in a match, then stop tracking this\n                // element. Otherwise, we'll continue to try and scroll\n                // it in the subsequent tick.\n                // --\n                // NOTE: We continue to try and update it because the\n                // target element may exist in the DOM but also be\n                // loading asynchronous data that is required for the\n                // previous scroll offset.\n                if (resultantScrollTop === scrollTop) {\n                  delete (pendingPageState[selector]);\n                }\n              }\n            }\n\n            // If there are no more elements to scroll or, we've exceeded our\n            // poll duration, then stop watching the DOM.\n            if (this.objectIsEmpty(pendingPageState)\n              || ((Date.now() - startedAt) >= this.config.pollDuration!)\n            ) {\n              clearTimeout(this.applyStateToDomTimer);\n              if (this.config.debug) {\n                if (this.objectIsEmpty(pendingPageState)) {\n                  console.log('%c Successfully reapplied all recorded scroll positions to the DOM.', 'color: #2ecc71');\n                } else {\n                  console.warn(`Could not reapply following recorded scroll positions to the DOM after a poll duration of: ${this.config.pollDuration} milliseconds:`);\n                  this.debugPageState(pendingPageState);\n                }\n              }\n            }\n          },\n          this.config.pollCadence\n        );\n      }\n    );\n  }\n\n  /**\n   * I get the page state from the given set of nodes. This extracts the CSS selectors and offsets from the recorded elements.\n   */\n  private getPageStateFromNodes(nodes: Set<Target>): PageState {\n    const pageState: PageState = {};\n\n    nodes.forEach(\n      target => {\n        // Generate a CSS selector from the given target.\n        // --\n        // TODO: Right now, this algorithm creates the selector by walking up the\n        // DOM tree and using the simulated encapsulation attributes. But, it\n        // would be cool to have a configuration option that tells this algorithm\n        // to look for a specific id-prefix or attribute or something. This would\n        // require the developer to provide those; but it would be optimal.\n        const selector = DomUtils.getSelector(target);\n\n        // If the given Target is no longer part of the active DOM, the selector\n        // will be null.\n        if (selector) {\n          pageState[selector] = DomUtils.getScrollTop(target);\n        }\n      }\n    );\n    return pageState;\n  }\n\n  /**\n   * I determine if the given object is empty (ie, has no keys).\n   */\n  private objectIsEmpty(object: Object): boolean {\n    for (const key in object) {\n      return false;\n    }\n    return true;\n  }\n\n  // The goal of the NavigationStart event is to take changes that have been made\n  // to the current DOM and store them in the render-state tree so they can be\n  // reinstated at a future date.\n  private handleNavigationStart(event: NavigationStart): void {\n    this.lastNavigationStartAt = Date.now();\n\n    // Get the navigation ID and the restored navigation ID for use in the\n    // NavigationEnd event handler.\n    this.navigationID = event.id;\n    /**\n     * Maybe in future update @todo: use ngx-navigation-trigger here, like: \n     * (event.restoredState && this.whenShouldScrollPositionBeRestored.has(this.navigationTrigger))\n     */\n    this.restoredNavigationID = event.restoredState ? event.restoredState.navigationId : null;\n\n    // If the user is navigating away from the current view, kill any timers that\n    // may be trying to reinstate a page-state.\n    clearTimeout(this.applyStateToDomTimer);\n\n    // Before we navigate away from the current page state, let's commit any\n    // scroll-elements to the current page state.\n    Object.assign(\n      this.currentPageState,\n      this.getPageStateFromNodes(this.scrolledElements)\n    );\n\n    this.scrolledElements.clear();\n\n    if (this.config.debug) {\n      this.debugPageState(this.currentPageState, 'Recorded scroll positions.');\n    }\n  };\n\n  // The primary goal of the NavigationEnd event is to reinstate a cached page\n  // state in the event that the navigation is restoring a previously rendered page\n  // as the result of a popstate event (ex, the user hit the Back or Forward\n  // buttons).\n  private handleNavigationEnd(): void {\n\n    const previousPageState = this.currentPageState;\n\n    // Now that we know the navigation was successful, let's start and store a\n    // new page state to track future scrolling.\n    this.currentPageState = this.pageStates[this.navigationID] = {};\n\n    // While we are going to track elements that will be scrolled during the\n    // current page rendering, it is possible that there are elements that were\n    // scrolled during a prior page rendering that still exist on the page, but\n    // were not scrolled recently (such as a secondary router-outlet). As such,\n    // let's look at the previous page state and 'pull forward' any state that\n    // still pertains to the current page.\n    if (!this.restoredNavigationID) {\n      for (const selector in previousPageState) {\n        const target = DomUtils.select(selector);\n\n        // Only pull the selector forward if it corresponds to an element\n        // that still exists in the rendered page.\n        if (!target) {\n          continue;\n        }\n\n        // Only pull the selector forward if the target is still at the same\n        // offset after the navigation has taken place. In other words, if\n        // the offset has somehow changed in between the NavigationStart and\n        // NavigationEnd events, then ignore it. To be honest, this really\n        // only applies to the WINDOW, which can change in offset due to the\n        // change in what the Router is actively rendering in the DOM.\n        if (DomUtils.getScrollTop(target) !== previousPageState[selector]) {\n          continue;\n        }\n\n        this.currentPageState[selector] = previousPageState[selector];\n\n        if (this.config.debug) {\n          console.group('Pulling scroll position from previous page state in current page state.');\n          console.log({\n            selector,\n            scrollPosition: this.currentPageState[selector]\n          });\n          console.groupEnd();\n        }\n      }\n\n      // If we're restoring a previous page state AND we have that previous page\n      // state cached in-memory, let's copy the previous state and then restore the\n      // offsets in the DOM.\n    } else if (this.restoredNavigationID && this.pageStates[this.restoredNavigationID]) {\n\n      // NOTE: We're copying the offsets from the restored state into the\n      // current state instead of just swapping the references because these\n      // navigations are different in the Router history. Since each navigation\n      // - imperative or popstate - gets a unique ID, we never truly 'go back'\n      // in history; the Router only 'goes forward', with the notion that we're\n      // recreating a previous state sometimes.\n      this.applyPageStateToDom(\n        Object.assign(\n          this.currentPageState,\n          this.pageStates[this.restoredNavigationID]\n        )\n      );\n    }\n\n    // Keep track of the navigation event so we can limit the size of our\n    // in-memory page state cache.\n    this.navigationIDs.push(this.navigationID);\n\n    // Trim the oldest page states as we go so that the in-memory cache doesn't\n    // grow, unbounded.\n    while (this.navigationIDs.length > this.maximumNumberOfCachedPageStates) {\n      delete (this.pageStates[this.navigationIDs.shift() as number]);\n    }\n  };\n\n  /**\n   * I bind to the scroll event and keep track of any elements that are scrolled in the rendered document.\n   */\n  private setupScrollBinding(): void {\n\n    /**\n     * Maybe @todo: You should try to find a way to get scrollable (scrolled) elements only during NavigationStart. \n     * Advantages:\n     * - Better performance: no need to listen to the scroll event the whole time.\n     * - Some elements might be added to the `scrolledElements` are not part of the DOM any more.\n     * Disavantages:\n     * - during NavigationStart scrollable elements that are maybe present after the intialization of page (before any user-interactions that can remove them) might be not part DOM any more.\n     * \n     */\n    // Add scroll-binding outside of the Angular Zone so it doesn't trigger any\n    // additional change-detection digests.\n    this.zone.runOutsideAngular(() => {\n      // When navigating, the browser emits some scroll events as the DOM \n      // (Document Object Model) changes shape in a way that forces the various\n      // scroll offsets to change. Since these scroll events are not indicative\n      // of a user's actual scrolling intent, we're going to ignore them. This\n      // needs to be done on both sides of the navigation event (for reasons\n      // that are not fully obvious or logical -- basically, the window's\n      // scroll changes at a time that is not easy to tap into). Ignoring these\n      // scroll events is important because the polyfilly stops trying to\n      // reinstate a scroll-offset if it sees that the given element has\n      // already been scrolled during the current rendering.\n      const scrollBufferWindow = 100;\n      let target: Target | null;\n\n      window.addEventListener(\n        'scroll',\n        event => {\n\n          // If the scroll event happens immediately following a\n          // navigation event, then ignore it - it is likely a scroll that\n          // was forced by the browser's native behavior.\n          if ((Date.now() - this.lastNavigationStartAt) < scrollBufferWindow) {\n            return;\n          }\n\n          // The target will return NULL for elements that have irrelevant\n          // scroll behaviors (like textarea inputs). As such, we have to\n          // check to see if the domUtils returned anything.\n          target = DomUtils.getTargetFromScrollEvent(event);\n          if (target) {\n            this.scrolledElements.add(target);\n          }\n        },\n        // We have to use the CAPTURING phase. Scroll events DO NOT BUBBLE.\n        // As such, if we want to listen for all scroll events in the \n        // document, we have to use the capturing phase (as the event travels\n        // down through the DOM tree).\n        true\n      );\n    });\n  }\n\n  private debugPageState(pageState: PageState, message?: string) {\n    if (this.objectIsEmpty(pageState)) {\n      return;\n    }\n    console.group(message || '');\n    for (const [selector, scrollPosition] of Object.entries(pageState)) {\n      console.log({\n        selector,\n        scrollPosition\n      });\n    }\n    console.groupEnd();\n  }\n\n  /**\n   * Disable browser default scroll restoration.\n   * \n   * Documentation:\n   * - https://developer.mozilla.org/en-US/docs/Web/API/History/scrollRestoration\n   */\n  private disableBrowserDefaultScrollRestoration(): void {\n    if ('scrollRestoration' in history) {\n      history.scrollRestoration = 'manual';\n    }\n  }\n}\n\ntype Target = Window | Element;\n\ninterface PageStates {\n  [navigationID: number]: PageState;\n}\n\ninterface PageState {\n  /**\n   * Scroll position (number).\n   */\n  [selector: string]: number;\n}\n\n/**\n * Source:\n * - https://www.bennadel.com/blog/3534-restoring-and-resetting-the-scroll-position-using-the-navigationstart-event-in-angular-7-0-4.htm\n * - http://bennadel.github.io/JavaScript-Demos/demos/router-retain-scroll-polyfill-angular7/\n * - https://github.com/bennadel/JavaScript-Demos/tree/master/demos/router-retain-scroll-polyfill-angular7\n */","\nimport { isPlatformServer } from '@angular/common';\nimport { Directive, Inject, OnDestroy, PLATFORM_ID } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { ActivatedRoute, Event as RouterNavigationEvent, NavigationStart } from '@angular/router';\nimport { NavigationEnd } from '@angular/router';\nimport { Router } from '@angular/router';\nimport { RouterOutlet } from '@angular/router';\nimport { Subject, takeUntil } from 'rxjs';\nimport * as DomUtils from './dom-utils';\nimport { NgxScrollPositionRestorationConfig } from './ngx-scroll-position-restoration-config';\nimport { NGX_SCROLL_POSITION_RESTORATION_CONFIG_INJECTION_TOKEN } from './ngx-scroll-position-restoration-config-injection-token';\nimport { NgxScrollPositionRestorationService } from './ngx-scroll-position-restoration.service';\n\nconst ANGULAR_DEFAULT_ROUTER_OUTLET_NAME = 'primary';\n\n/**\n * I co-opt the <router-outlet> element selector so that I can tap into the life-cycle of the core RouterOutlet directive.\n * \n * REASON: When the user clicks on a link, it's quite hard to differentiate between a primary navigation, which should probably scroll the user back to the top of the viewport; and, something like a tabbed-navigation, which should probably keep the user's scroll around the offset associated with the tab. As such, we are going to rely on the inherent scroll-position of the view as the router-outlet target is pulled out of the DOM.\n * PS: Keep in mind in Angular per default scroll position is maintained on navigation.\n */\n@Directive({\n  selector: 'router-outlet'\n})\nexport class CustomRouterOutletDirective implements OnDestroy {\n\n  private recordedScrollPositions: RecordedScrollPosition[] = [];\n\n  private directiveDestroyed$ = new Subject<void>();\n\n  private navigationTrigger: 'imperative' | 'popstate' | 'hashchange' | undefined;\n\n  constructor(\n    private elementRef: ElementRef<Element>,\n    private router: Router,\n    private routerOutlet: RouterOutlet,\n    private ngxScrollPositionRestorationService: NgxScrollPositionRestorationService,\n    @Inject(PLATFORM_ID) private platformId: string,\n    @Inject(NGX_SCROLL_POSITION_RESTORATION_CONFIG_INJECTION_TOKEN) private config: NgxScrollPositionRestorationConfig\n  ) { }\n\n  ngOnInit(): void {\n    if (isPlatformServer(this.platformId)) {\n      return;\n    }\n\n    this.routerOutlet.activateEvents.pipe(\n      takeUntil(this.directiveDestroyed$)\n    ).subscribe(() => this.handleActivateEvent());\n\n    this.routerOutlet.deactivateEvents.pipe(\n      takeUntil(this.directiveDestroyed$)\n    ).subscribe(() => this.handleDectivateEvent());\n\n    this.router.events.pipe(\n      takeUntil(this.directiveDestroyed$)\n    ).subscribe((event: RouterNavigationEvent) => this.handleNavigationEvent(event));\n  }\n\n  ngOnDestroy(): void {\n    this.directiveDestroyed$.next();\n    this.directiveDestroyed$.complete();\n  }\n\n  /**\n   * Called when a router-outlet component has been rendered.\n   */\n  private handleActivateEvent(): void {\n    const currentRouterOutletName = this.routerOutlet.activatedRoute.outlet;\n    const currentNavigation = this.router.getCurrentNavigation();\n    if (currentRouterOutletName !== ANGULAR_DEFAULT_ROUTER_OUTLET_NAME\n      && !(currentNavigation?.extras?.skipLocationChange)) {\n      this.ngxScrollPositionRestorationService.clearSavedWindowScrollTopInLastNavigation();\n    }\n\n    const isRootRouterOutlet = this.isRootRouterOutlet(this.routerOutlet.activatedRoute);\n    if (isRootRouterOutlet\n      && this.navigationTrigger === 'imperative'\n      && this.routerOutlet.activatedRoute.outlet === ANGULAR_DEFAULT_ROUTER_OUTLET_NAME) {\n      DomUtils.scrollTo(window, 0);\n      if (this.config.debug) {\n        console.log('Imperative navigation: scrolled to the top (scrollTop = 0) of the window.');\n      }\n    } else {\n\n      // At this point, the View-in-question has been mounted in the DOM (Document\n      // Object Model). We can now walk back up the DOM and make sure that the\n      // previously-recorded offsets (in the last 'deactivate' event) are being applied\n      // to the ancestral elements. This will prevent the browser's native desire to \n      // auto-scroll-down a document once the view has been injected. Essentially, this\n      // ensures that we scroll back to the 'expected top' as the user clicks through\n      // the application.\n\n      if (this.config.debug) {\n        console.group(`router-outlet (\"${this.elementRef.nativeElement.getAttribute('name') || ANGULAR_DEFAULT_ROUTER_OUTLET_NAME}\") - Reapply recorded scroll positions.`);\n        console.log(this.recordedScrollPositions.slice());\n        console.groupEnd();\n      }\n\n      if (this.recordedScrollPositions.length === 0) {\n        return;\n      }\n\n      for (const { elementSelector, scrollPosition } of this.recordedScrollPositions) {\n        if (elementSelector) {\n          const element = DomUtils.select(elementSelector);\n          if (element) {\n            DomUtils.scrollTo(element, scrollPosition);\n          }\n        }\n      }\n\n      this.recordedScrollPositions = [];\n    }\n  }\n\n  /**\n   * Called when a router-outlet component has been destroyed from the DOM. This means, at this point, the scroll position of the scrollable element containing the router-outlet component should be `0` (@todo: (BUG) but this seems not to work in Angular@13.1.1: component is not destroyed at this point).\n   */\n  private handleDectivateEvent(): void {\n\n    // At this point, the View-in-question has already been removed from the \n    // document. Let's walk up the DOM (Document Object Model) and record the scroll\n    // position of all scrollable elements. This will give us a sense of what the DOM\n    // should look like after the next View is injected.\n    let node = this.elementRef.nativeElement.parentNode as Element;\n    while (node && node.tagName !== 'BODY') {\n      // If this is an \"Element\" node, capture its offset.\n      if (node.nodeType === 1) {\n        const scrollTop = DomUtils.getScrollTop(node);\n        const elementSelector = DomUtils.getSelector(node);\n        this.recordedScrollPositions.push({\n          elementSelector,\n          target: node,\n          scrollPosition: scrollTop\n        });\n      }\n      node = node.parentNode as Element;\n    }\n\n    if (this.config.debug) {\n      console.group(`router-outlet (\"${this.elementRef.nativeElement.getAttribute('name') || ANGULAR_DEFAULT_ROUTER_OUTLET_NAME}\") - Recorded scroll positions.`);\n      console.log(this.recordedScrollPositions.slice());\n      console.groupEnd();\n    }\n  }\n\n  /**\n   * I get called whenever a router event is raised.\n   */\n  private handleNavigationEvent(event: RouterNavigationEvent): void {\n    if (event instanceof NavigationStart) {\n      this.navigationTrigger = event.navigationTrigger;\n    }\n\n    // The 'offsets' are only meant to be used across a single navigation. As such,\n    // let's clear out the offsets at the end of each navigation in order to ensure\n    // that old offsets don't accidentally get applied to a future view mounted by\n    // the current router-outlet.\n    if (event instanceof NavigationEnd) {\n      this.recordedScrollPositions = [];\n    }\n  }\n\n  /**\n   * Is root \"primary\" (or any secondary) router-outet.\n   */\n  private isRootRouterOutlet(actvitedRoute: ActivatedRoute): boolean {\n    const currentComponent = actvitedRoute.component;\n    const parentChildren = actvitedRoute.parent?.routeConfig?.children;\n    if (!Array.isArray(parentChildren)) {\n      return true;\n    }\n\n    for (const route of parentChildren) {\n      if (route.component === currentComponent) {\n        return false;\n      }\n    }\n    return true;\n\n    // Alternative: solution 02 (but not valid for secondary router-outlet)\n    // if (actvitedRoute.parent?.component) {\n    //   return false;\n    // } else {\n    //   return true;\n    // }\n  }\n}\n\ninterface RecordedScrollPosition {\n  elementSelector: string | null;\n  scrollPosition: number;\n  target: any\n}\n\n/**\n * Source:\n * - https://www.bennadel.com/blog/3534-restoring-and-resetting-the-scroll-position-using-the-navigationstart-event-in-angular-7-0-4.htm\n * - http://bennadel.github.io/JavaScript-Demos/demos/router-retain-scroll-polyfill-angular7/\n * - https://github.com/bennadel/JavaScript-Demos/tree/master/demos/router-retain-scroll-polyfill-angular7\n */","import { NgxScrollPositionRestorationConfig } from './ngx-scroll-position-restoration-config';\n\nexport const defaultNgxScrollPositionRestorationConfig: NgxScrollPositionRestorationConfig = {\n  pollDuration: 3000,\n  pollCadence: 50,\n  debug: false\n};\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { CustomRouterOutletDirective } from './custom-router-outlet.directive';\nimport { defaultNgxScrollPositionRestorationConfig } from './default-ngx-scroll-position-restoration-config';\nimport { NgxScrollPositionRestorationConfig } from './ngx-scroll-position-restoration-config';\nimport { NGX_SCROLL_POSITION_RESTORATION_CONFIG_INJECTION_TOKEN } from './ngx-scroll-position-restoration-config-injection-token';\nimport { NgxScrollPositionRestorationService } from './ngx-scroll-position-restoration.service';\n\n@NgModule({\n  declarations: [\n    CustomRouterOutletDirective\n  ],\n  exports: [\n    CustomRouterOutletDirective\n  ],\n  providers: [\n    NgxScrollPositionRestorationService\n  ]\n})\nexport class NgxScrollPositionRestorationModule {\n\n  /**\n   * Since NgxScrollPositionRestorationModule can be imported in child modules, it is needed to track if the ngxScrollPositionRestorationService has been already initialized to avoid duplicate calls of the `initialize` method. \n   */\n  private static serviceInitialized = false;\n\n  constructor(ngxScrollPositionRestorationService: NgxScrollPositionRestorationService) {\n    if (!NgxScrollPositionRestorationModule.serviceInitialized) {\n      ngxScrollPositionRestorationService.initialize();\n      NgxScrollPositionRestorationModule.serviceInitialized = true;\n    }\n  }\n\n  static forRoot(config?: NgxScrollPositionRestorationConfig): ModuleWithProviders<NgxScrollPositionRestorationModule> {\n    return ({\n      ngModule: NgxScrollPositionRestorationModule,\n      providers: [\n        {\n          provide: NGX_SCROLL_POSITION_RESTORATION_CONFIG_INJECTION_TOKEN,\n          useValue: Object.assign(defaultNgxScrollPositionRestorationConfig, config)\n        }\n      ]\n    });\n  }\n}\n","/*\n * Public API Surface of ngx-scroll-position-restoration\n */\n\nexport * from './lib/ngx-scroll-position-restoration.module';\nexport * from './lib/ngx-scroll-position-restoration-config';\nexport * from './lib/custom-router-outlet.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["DomUtils.WINDOW_SELECTOR","DomUtils.select","DomUtils.scrollTo","DomUtils.getSelector","DomUtils.getScrollTop","DomUtils.getTargetFromScrollEvent"],"mappings":"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"}